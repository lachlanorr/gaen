//------------------------------------------------------------------------------
// hashes.cpp - Precalculated hashes, generated by update_hashes.py
//
// Gaen Concurrency Engine - http://gaen.org
// Copyright (c) 2014-2022 Lachlan Orr
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
//   1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
//
//   2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
//
//   3. This notice may not be removed or altered from any source
//   distribution.
//------------------------------------------------------------------------------

#include "gaen/core/thread_local.h"
#include "gaen/core/hashing.h"
#include "gaen/hashes/hashes.h"

#if HAS(TRACK_HASHES)
#include <mutex>
#include "gaen/core/HashMap.h"
#include "gaen/core/String.h"
#endif // #if HAS(TRACK_HASHES)

#define HASH_FUNC ::gaen::gaen_hash

namespace gaen
{

#if HAS(TRACK_HASHES)
typedef HashMap<kMEM_Debug, u32, String<kMEM_Debug>> TrackMap;
static std::mutex sTrackMapMutex;
static TrackMap sTrackMap;
static TrackMap sTrackMapHashes;
// Insert all our precalculated hashes into sTrackMap so we will know
// if we encounter conflicts in dynamically calculated hashes.  Also,
// verify the precalculted hashes match what our C++ version returns.
bool build_initial_track_map()
{
    sTrackMap.rehash(8192);
${hashes_map_insertions}
    return true;
}

namespace
{
    bool ret = build_initial_track_map();
}
#endif // #if HAS(TRACK_HASHES)

u32 HASH::hash_func(const char *str)
{
    ASSERT(str);

    u32 hval = HASH_FUNC(str);

#if HAS(TRACK_HASHES)
    {
        std::lock_guard<std::mutex> lock(sTrackMapMutex);
        auto it = sTrackMap.find(hval);
        if (it != sTrackMap.end())
        {
            // If strings don't match, you have two distinct strings whose
            // hashes clash.  This will likely break stuff in horrific
            // ways.  You need to tweak one of the strings, change its
            // value slightly and the problem should be resolved.
            if (0 != strcmp(it->second.c_str(), str))
                ERR("Hash Clash Detected: %s and %s", it->second.c_str(), str);
        }
        else
        {
            sTrackMap.emplace(hval, str);
        }
    }
#endif // #if HAS(TRACK_HASHES)

    // return our new hash value
    return hval;
}

const char * HASH::reverse_hash(u32 hash)
{
#if HAS(TRACK_HASHES)
    TLARRAY(char, tMessage, 20);
    {
        std::lock_guard<std::mutex> lock(sTrackMapMutex);
        auto it = sTrackMap.find(hash);
        if (it != sTrackMap.end())
        {
            return it->second.c_str();
        }
        else
        {
            auto ith = sTrackMapHashes.find(hash);
            if (ith == sTrackMapHashes.end())
            {
                sprintf(tMessage, "0x%08x", hash);
                ith = sTrackMapHashes.emplace(hash, tMessage).first;
            }
            return ith->second.c_str();
        }
    }
#else  // #if HAS(TRACK_HASHES)
    return "HASH_TRACKING_NOT_ENABLED";
#endif // #if HAS(TRACK_HASHES)
}

} // namespace gaen
